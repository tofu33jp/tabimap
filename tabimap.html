<!DOCTYPE html>
<html>
<head>
    <title>tabimap</title>
    <style>
        #map { height: 100vh; width: 100%; }
        body { margin: 0; padding: 0; }
    </style>
</head>
<body>
    <div id="map"></div>

    <div id="legend">
        <h4>凡例</h4>
        <div id="legend-content"></div>
    </div>

    <style>
        #legend {
            background: white;
            padding: 10px;
            margin: 10px;
            border: 1px solid #ccc;
            font-family: Arial, sans-serif;
            font-size: 12px;
            line-height: 1.5;
        }
        .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
        .color-box { width: 15px; height: 15px; margin-right: 8px; border-radius: 50%; }
    </style>

    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD0kkOQYlPMdYMNlqrmOI7AWhhTJC_MSlA&callback=initMap&v=weekly" defer></script>
    
    <script src="https://unpkg.com/@googlemaps/markerclusterer/dist/index.min.js"></script>

    <script>
        let map;
        let markerCluster;
        let markers = [];
        let infoWindow;

        async function initMap() {
            // 地図の初期化（東京中心）
            map = new google.maps.Map(document.getElementById("map"), {
                zoom: 12,
                center: { lat: 35.6812, lng: 139.7671 },
                scaleControl: true,
                gestureHandling: "greedy",
                mapId: "DEMO_MAP_ID" // 独自のスタイルを使う場合に必要
            });

            infoWindow = new google.maps.InfoWindow();

            // クラスター管理者の初期化
            markerCluster = new markerClusterer.MarkerClusterer({ map, markers: [] });

            // 地図が動いた（ズーム・移動）後のイベント
            map.addListener("idle", () => {
                if (map.getZoom() < 13) { // ズームレベルが13（街が見える程度）より小さければ読み込まない
                    console.log("Too zoomed out");
                    return;
                }
                fetchPointsInBounds();
                fetchLinesInBounds();
                fetchPolygonsInBounds();
            });

            // 地図の背景をクリックしたらハイライトを解除
            map.addListener("click", () => {
                if (selectedPolyline) {
                    selectedPolyline.setOptions({
                        strokeColor: selectedPolyline.originalConfig.color,
                        strokeWeight: selectedPolyline.originalConfig.weight || 3,
                        strokeOpacity: 0.7,
                        zIndex: 1
                    });
                    selectedPolyline = null;
                    infoWindow.close();
                }
            });

            // 凡例を自動生成して地図上に配置
            const legendContent = document.getElementById("legend-content");
            for (const key in TYPE_CONFIG) {
                if (key === "DEFAULT") continue;
                const item = TYPE_CONFIG[key];
                legendContent.innerHTML += `
                    <div class="legend-item">
                        <div class="color-box" style="background-color: ${item.color}"></div>
                        <span>${item.label}</span>
                    </div>
                `;
            }
            // Google Mapsの右下に配置
            map.controls[google.maps.ControlPosition.LEFT_BOTTOM].push(document.getElementById("legend"));
        }

        async function fetchPointsInBounds() {
            const bounds = map.getBounds();
            if (!bounds) return;

            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();

            // Renderで発行されたURLに書き換え
            const baseUrl = "https://tabimap-api.onrender.com"; 
            const url = `${baseUrl}/points?west=${sw.lng()}&south=${sw.lat()}&east=${ne.lng()}&north=${ne.lat()}`;

            try {
                const response = await fetch(url);
                const geojsonData = await response.json(); // ここで直接JSONとして受け取る
                updateMarkers(geojsonData.features);
            } catch (error) {
                console.error("Fetch error:", error);
            }
        }

        // 1. 種類ごとの色設定を「辞書（オブジェクト）」として定義
        const TYPE_CONFIG = {
                "RAILWAY(JR)": { color: "#FF4B00", label: "鉄道(JR)" },
                "RAILWAY(OTHER)":    { color: "#F6AA00", label: "鉄道(他)" },
                "EXBUS":    { color: "#03AF7A", label: "高速バス" },
                "BUS":     { color: "#005AFF", label: "路線バス", weight: 4 },
                "PORT":   { color: "#804000", label: "空港・旅客港" },
                "OTHER":   { color: "#990099", label: "観光地" },
                "DEFAULT": { color: "#7F7F7F", label: "その他" }
            };
        // レベルごとの色の塗り分け設定
        const LEVEL_STYLE = {
            "A": { color: "#FF0000", opacity: 0.6 }, // 濃い赤
            "B": { color: "#FF0000", opacity: 0.45 }, // 中間の赤
            "C": { color: "#FF0000", opacity: 0.3 }, // 薄い赤
            "D": { color: "#FF0000", opacity: 0.15 }, // 薄い赤
            "E": { color: "#FF0000", opacity: 0 }, // 薄い赤
            "DEFAULT": { color: "#808080", opacity: 0.1 }
        };
        function updateMarkers(features) {
            // 古いマーカーを削除
            markers.forEach(m => m.setMap(null));
            markers = [];
            markerCluster.clearMarkers();

            // 新しいマーカーを作成
            markers = features.map(feature => {
                const [lng, lat] = feature.geometry.coordinates;
                const { name, type, description } = feature.properties;

                // 2. 設定表から色を取得。登録がない場合はDEFAULTを使う
                const config = TYPE_CONFIG[type] || TYPE_CONFIG["DEFAULT"];
                const color = config.color;
                // 種類によって色を変える
                // const color = (type === "BUS") ? "#1E90FF" : "#FF4500"; // バス:青, 鉄道:赤

                const marker = new google.maps.Marker({
                    position: { lat, lng },
                    title: name, // ホバー時に表示される
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: color,
                        fillOpacity: 1.0,
                        strokeColor: "white",
                        strokeWeight: 2,
                        scale: 8,
                        zIndex: 3
                    }
                });

                // クリックイベント
                marker.addListener("click", () => {
                    infoWindow.setContent(`<strong>${name}</strong> (${config.label})<hr>${description}`);
                    infoWindow.open(map, marker);
                });

                return marker;
            });

            // クラスターに追加
            markerCluster.addMarkers(markers);
        }
        
        let polylines = []; // 描画中の線を保持する配列
        let selectedFeatureId = null; // ★現在選択（クリック）されているラインを保持
        async function fetchLinesInBounds() {
            const bounds = map.getBounds();
            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();
        
            const baseUrl = "https://tabimap-api.onrender.com"; 
            const url = `${baseUrl}/lines?west=${sw.lng()}&south=${sw.lat()}&east=${ne.lng()}&north=${ne.lat()}`;
        
            try {
                const response = await fetch(url);
                const geojsonData = await response.json();
                updateLines(geojsonData.features);
            } catch (error) {
                console.error("Lines fetch error:", error);
            }
        }
        
        function updateLines(features) {
            polylines.forEach(p => p.setMap(null));
            polylines = [];
            selectedFeatureId = null;

            if (!features) return;

            features.forEach((feature, index) => {
                if (!feature.geometry || !feature.geometry.coordinates) return;

                const config = TYPE_CONFIG["BUS"];
                const geomType = feature.geometry.type;
                
                // ★ 路線を特定するためのユニークな値（名前、あるいはID）
                const featureId = feature.properties.ix;

                const convertCoords = (coords) => coords.map(c => ({ lat: c[1], lng: c[0] }));

                let paths = [];
                if (geomType === "LineString") {
                    paths.push(convertCoords(feature.geometry.coordinates));
                } else if (geomType === "MultiLineString") {
                    feature.geometry.coordinates.forEach(subCoords => paths.push(convertCoords(subCoords)));
                }

                paths.forEach(path => {
                    const polyline = new google.maps.Polyline({
                        path: path,
                        geodesic: true,
                        strokeColor: config.color,
                        strokeOpacity: 0.7,
                        strokeWeight: config.weight || 3,
                        map: map,
                        zIndex: 1,
                        // ★ 独自プロパティとして情報を保持させる
                        featureId: featureId, 
                        originalConfig: config 
                    });

                    // クリックイベント
                    polyline.addListener("click", (e) => {
                        highlightFeature(featureId, e.latLng, feature.properties);
                    });

                    polylines.push(polyline);
                });
            });
        }

        // ★ 同じIDを持つ全てのラインをハイライトする関数
        function highlightFeature(id, latLng, properties) {
            // 1. まず全てのラインを元のスタイルに戻す
            polylines.forEach(p => {
                p.setOptions({
                    strokeColor: p.originalConfig.color,
                    strokeWeight: p.originalConfig.weight || 3,
                    strokeOpacity: 0.7,
                    zIndex: 1
                });
            });

            // 2. 同じID（featureId）を持つラインだけを全て強調する
            polylines.filter(p => p.featureId === id).forEach(p => {
                p.setOptions({
                    strokeColor: "#000000", // ハイライト色
                    strokeWeight: 8,
                    strokeOpacity: 1.0,
                    zIndex: 100
                });
            });

            selectedFeatureId = id;

            // 3. 情報表示
            // infoWindow.setContent(`<strong>${properties.name || "名称不明"}</strong>`);
            // infoWindow.setPosition(latLng);
            // infoWindow.open(map);
        }


        let polygons = [];
        async function fetchPolygonsInBounds() {
            const bounds = map.getBounds();
            if (!bounds) return;

            const ne = bounds.getNorthEast();
            const sw = bounds.getSouthWest();
            const baseUrl = "https://tabimap-api.onrender.com"; 
            const url = `${baseUrl}/polygons?west=${sw.lng()}&south=${sw.lat()}&east=${ne.lng()}&north=${ne.lat()}`;

            try {
                const response = await fetch(url);
                const geojsonData = await response.json();
                updatePolygons(geojsonData.features);
            } catch (error) {
                console.error("Polygons fetch error:", error);
            }
        }

        function updatePolygons(features) {
            polygons.forEach(p => p.setMap(null));
            polygons = [];

            features.forEach(feature => {
                if (!feature.geometry || !feature.geometry.coordinates) return;

                const { name, description } = feature.properties;
                // Polygon または MultiPolygon の座標変換
                const geomType = feature.geometry.type;
                const level = feature.properties.level;
                const style = LEVEL_STYLE[level] || LEVEL_STYLE["DEFAULT"];

                // Google Maps 形式に変換（[lng, lat] -> {lat, lng}）
                // Polygon は配列が一段深い（[外周, 穴, 穴...]）ことに注意
                const processCoords = (coords) => coords.map(ring => 
                    ring.map(c => ({ lat: c[1], lng: c[0] }))
                );

                let paths = [];
                if (geomType === "Polygon") {
                    paths = processCoords(feature.geometry.coordinates);
                } else if (geomType === "MultiPolygon") {
                    feature.geometry.coordinates.forEach(polyCoords => {
                        paths.push(...processCoords(polyCoords));
                    });
                }

                const polygon = new google.maps.Polygon({
                    paths: paths,
                    title: name, // ホバー時に表示される
                    strokeColor: style.color,
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    fillColor: style.color,
                    fillOpacity: style.opacity,
                    map: map,
                    zIndex: 0 // ポリゴンは一番下に表示
                });

                // クリック時に情報を表示
                polygon.addListener("click", (e) => {
                    infoWindow.setContent(`<strong>${name}</strong><hr>${description}`);
                    infoWindow.setPosition(e.latLng);
                    infoWindow.open(map);
                });

                polylines.push(polygon); // 配列に入れて管理
            });
        }

    </script>
</body>
</html>
